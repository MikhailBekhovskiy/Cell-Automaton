# Cell-Automaton
Минималистичная реализация клеточного автомата Конвея (игра "жизнь").

## Правила игры (законы жизни автомата)
Предложим слегка модифицированные правила игры "жизнь" для упрощения реализации.
Клеточная колония обитает на квадратном поле задаваемого пользователем размера.
Каждая клетка квадратного поля находится в одном из двух состояний: "живой" или "мертвый".
Исходное состояние (распределение "живых" и "мертвых" клеток) определяется случайным образом.
Переход между состояниями поля происходит по следующим правилам:
- Если у "мертвой" клетки три "живых" соседа, она "оживает". В остальных случаях она остается "мертвой"
- Если у "живой" клетки два или три "живых" соседа, она остается "живой". В остальных случаях она "умирает".
Жизнь (переход между состояниями) может продолжаться, пока на поле есть хотя бы одна живая клетка. Подробнее о правилах остановки см раздел реализации.
## Реализация игры
В этом разделе опишем, как можно реализовать:
- Игровое квадратное поле.
- Генерацию исходной клеточной колонии.
- Законы жизнедеятельности колонии.
- Условия остановки симуляции жизни колонии.
- Визуализацию жизни колонии.
### Игровое поле
Квадратное поле, содержащее в каждой своей клетке какие-либо данные, реализуется при помощи двумерного массива. В Python массивы (тип list-"список") по умолчанию поддерживают вложенность. Благодаря этому без дополнительных манипуляций можем строки (массивы) квадратного поля собрать в один массив, который и будет представлять игровое поле.
Например:
field = [
    ["ж", "м", "ж"],
    ["м", "м", "м"],
    ["ж", "ж", "ж"]
]
может представлять одно из возможных состояний игрового поля размером 3х3 ("ж" - живая клетка, "м" - мертвая). Поскольку поле квадратное, число строк совпадает с длиной каждой из них (len(field) == len(field[i]) для i = [0,len(field) - 1]).
### Состояния клеток
Так как клетки могут находится только в двух состояниях, для кодирования достаточно двух символов. Компьютеру "легче" всего работать с числами, поэтому каждая клетка имеет либо значение 0(мертва), либо 1(жива). При визуализации 0 и 1 замещаются более приятными глазу автора символами.
### Генерация начального состояния
Начальное состояние создается так:
- вводится квадратный двумерный массив из 0 заданного аргументом функции размера
- при проходе двойным циклом по всем элементам введенного массива в каждой клетке "подбрасывается монетка" (случайным образом при помощи функции randint() из библиотеки random определяется, поменять ли значение клетки на 1).

Результатом функции является двумерный массив, в котором на случайных полях "разбросаны" 0 и 1.
### Подсчет живых соседей
При помощи цикла можем перебрать всех соседей любой из клеток поля. Во время этого цикла подсчитываем число встреченных 1.
### Основной цикл перехода состояний
Так как изменение должно происходить одновременно для всех клеток, текущее состояние необходимо хранить до полноценного осуществления перехода. Таким образом новое состояние записывается не вместо старого, а в новый двумерный массив того же размера:
- создается двумерный массив из 0 размера игрового поля
- двойным циклом перебираем все клетки текущего состояния
- в каждой клетке подсчитываем число живых соседей
- в соответствии с правилами, полученным числом живых соседей и текущим состоянием каждой клетки в соответствующую клетку нового состояния записываем 0 (клетка останется/станет мертвой) или 1 (останется/станет живой)
- новое состояние сохраняем как текущее и зацикливаемся.
### Условия остановки симуляции
Можно выделить два бросающихся в глаза частных случая, при которых менять дальше состояние не имеет смысла:
- все клетки умерли
- колония пришла в статичное состояние (новое состояние совпадает с текущим)
Вообще говоря, жизнь колонии может попасть в периодичность длиной более одного шага. Поэтому общее условие остановки можно сформулировать так:
- новое состояние совпадает с ОДНИМ ИЗ состояний, полученных с начала симуляции.
В этом случае нам необходимо хранить описание всех состояний, начиная с самого первого (назовем это описание историей). После создания нового состояния можем циклом перебрать всю историю и проверить, встречалось ли совпадающее с новым состояние ранее.
### Визуализация состояния автомата

### Возможные улучшения