# Cell-Automaton
Минималистичная реализация клеточного автомата Конвея (игра "жизнь").

## Правила игры (законы жизни автомата)
Предложим слегка модифицированные правила игры "жизнь" для упрощения реализации.
Клеточная колония обитает на квадратном поле задаваемого пользователем размера.
Каждая клетка квадратного поля находится в одном из двух состояний: "живой" или "мертвый".
Исходное состояние (распределение "живых" и "мертвых" клеток) определяется случайным образом.
Переход между состояниями поля происходит по следующим правилам:
- Если у "мертвой" клетки три "живых" соседа, она "оживает". В остальных случаях она остается "мертвой"
- Если у "живой" клетки два или три "живых" соседа, она остается "живой". В остальных случаях она "умирает".
Жизнь (переход между состояниями) может продолжаться, пока на поле есть хотя бы одна живая клетка. Подробнее о правилах остановки см раздел реализации.
## Реализация игры
В этом разделе опишем, как можно реализовать:
- Игровое квадратное поле.
- Генерацию исходной клеточной колонии.
- Законы жизнедеятельности колонии.
- Условия остановки симуляции жизни колонии.
- Визуализацию жизни колонии.
### Игровое поле
Квадратное поле, содержащее в каждой своей клетке какие-либо данные, реализуется при помощи двумерного массива. В Python массивы (тип list-"список") по умолчанию поддерживают вложенность. Благодаря этому без дополнительных манипуляций можем строки (массивы) квадратного поля собрать в один массив, который и будет представлять игровое поле.
Например:
field = [
    ["ж", "м", "ж"],
    ["м", "м", "м"],
    ["ж", "ж", "ж"]
]
может представлять одно из возможных состояний игрового поля размером 3х3 ("ж" - живая клетка, "м" - мертвая). Поскольку поле квадратное, число строк совпадает с длиной каждой из них (len(field) == len(field[i]) для i = [0,len(field) - 1]).
### Состояния клеток
Так как клетки могут находится только в двух состояниях, для кодирования достаточно двух символов. Компьютеру "легче" всего работать с числами, поэтому каждая клетка имеет либо значение 0(мертва), либо 1(жива). При визуализации 0 и 1 замещаются более приятными глазу автора символами.
### Генерация начального состояния
Начальное состояние создается так:
- вводится квадратный двумерный массив из 0 заданного аргументом функции размера
- при проходе двойным циклом по всем элементам введенного массива в каждой клетке "подбрасывается монетка" (случайным образом при помощи функции randint() из библиотеки random определяется, поменять ли значение клетки на 1).

Результатом функции является двумерный массив, в котором на случайных полях "разбросаны" 0 и 1.
### Подсчет живых соседей
При помощи цикла можем перебрать всех соседей любой из клеток поля. Во время этого цикла подсчитываем число встреченных 1.
### Основной цикл перехода состояний

### Условия остановки симуляции

### Визуализация состояния автомата

### Возможные улучшения