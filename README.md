# Cell-Automaton
Минималистичная реализация клеточного автомата Конвея (игра "жизнь").

# Правила игры (законы жизни автомата)
Предложим слегка модифицированные правила игры "жизнь" для упрощения реализации.
Клеточная колония обитает на квадратном поле задаваемого пользователем размера.
Каждая клетка квадратного поля находится в одном из двух состояний: живой или мертвый.
Исходное состояние (распределение живых и мертвых клеток) определяется случайным образом.
Переход между состояниями поля происходит по следующим правилам:
1. Если у мертвой клетки три живых соседа, она оживает. В остальных случаях она остается мертвой.
2. Если у живой клетки два или три живых соседа, она остается живой. В остальных случаях она умирает.
Жизнь (переход между состояниями) может продолжаться, пока на поле есть хотя бы одна живая клетка. Подробнее о правилах остановки см раздел реализации.

# Реализация игры
На верхнем уровне реализация разделяется на два этапа:
1. Симуляция жизни колонии с сохранением состояний.
2. Визуализация жизни колонии (производится после просчета, чтобы между состояниями компьютеру не надо было "думать" и потенциально тормозить).

Для просчета состояний необходимо реализовать:
- Игровое квадратное поле.
- Генерацию исходной клеточной колонии.
- Законы жизни колонии.
- Условия остановки жизни колонии.

Для визуализации необходимо приводить закодированное состояние колонии в понятный и приятный (тут уж кому как) человеческому глазу формат и в этом формате последовательно выводить на экран все сохраненные состояния.

## Симуляция жизни
### Игровое поле
Квадратное поле, содержащее в каждой своей клетке какие-либо данные, реализуется при помощи двумерного массива. В Python массивы (тип list -- "список") по умолчанию поддерживают вложенность. Благодаря этому без дополнительных манипуляций можем строки (массивы) квадратного поля собрать в один массив, который и будет представлять игровое поле.
Например:
```
field = [
    ["ж", "м", "ж"],
    ["м", "м", "м"],
    ["ж", "ж", "ж"]
]
```
может представлять одно из возможных состояний игрового поля размером 3х3 ("ж" - живая клетка, "м" - мертвая). Поскольку поле квадратное, число строк совпадает с длиной каждой из них (len(field) == len(field[i]) для i = [0,len(field) - 1]).

### Состояния клеток
Так как клетки могут находится только в двух состояниях, для кодирования достаточно двух символов. Компьютеру "легче" всего работать с числами, поэтому каждая клетка имеет либо значение 0 (мертва), либо 1 (жива). При визуализации 0 и 1 замещаются более приятными глазу автора символами.

### Генерация начального состояния
Начальное состояние создается так:
- Вводится квадратный двумерный массив из 0 заданного аргументом n типа int (целочисленный) размера.
- При проходе двойным циклом по всем элементам введенного массива в каждой клетке "подбрасывается монетка" (случайным образом при помощи функции randint() из библиотеки random определяется, поменять ли значение клетки на 1).

Результатом функции является двумерный массив, в котором на случайных полях "разбросаны" 0 и 1.

```
from random import randint

def bin_matr(n: int)->list:
    B = zeros(n)
    for i in range(n):
        for j in range(n):
            B[i][j] = randint(0,1)
    return B
```

### Подсчет живых соседей
При помощи цикла можем перебрать всех соседей любой из клеток поля. Во время этого цикла подсчитываем число встреченных 1. Просматриваем весь квадратик 3х3, центром которого является изучаемая клетка, пропуская ее саму. У граничных клеток будут не все соседи, поэтому также проверяем, не вываливаемся ли мы за границы поля.

```
def count_alive_neighbours(A: list, i: int, j: int) -> int:
    res = 0
    for k in range (i-1, i+2):
        for l in range(j-1, j+2):
            if k < len(A) and l < len(A) and k >= 0 and l >= 0 and (k != i or l != j):
                if A[k][l] == 1:
                    res += 1
    return res
```
### Основной цикл перехода состояний
Так как изменение должно происходить одновременно для всех клеток, текущее состояние необходимо хранить до полноценного осуществления перехода. Таким образом новое состояние записывается не вместо старого, а в новый двумерный массив того же размера:

1. Cоздается двумерный массив из 0 размера игрового поля.
2. Двойным циклом перебираем все клетки текущего состояния.
3. В каждой клетке подсчитываем число живых соседей.
4. В соответствии с правилами, полученным числом живых соседей и текущим состоянием каждой клетки в соответствующую клетку нового состояния записываем 0 (клетка останется/станет мертвой) или 1 (останется/станет живой).
5. Новое состояние сохраняем как текущее и зацикливаемся.

### Условия остановки симуляции
Можно выделить два бросающихся в глаза частных случая, при которых менять дальше состояние не имеет смысла:
1. Все клетки умерли.
2. Колония пришла в статичное состояние (новое состояние совпадает с текущим).
Вообще говоря, жизнь колонии может попасть в периодичность длиной более одного шага. Поэтому общее условие остановки можно сформулировать так:
> новое состояние совпадает с ОДНИМ ИЗ состояний, полученных с начала симуляции.

Для проверки общего условия нам необходимо хранить все состояния, начиная с самого первого (назовем это описание _историей_). После создания нового состояния можем циклом перебрать всю историю и проверить, встречалось ли совпадающее с новым состояние ранее. На каждом шаге история пополняется новым состоянием, а впоследствии история используется для визуализации.

## Визуализация состояния автомата
История содержит всю информацию о жизни клеточного автомата. Мы можем последовательно выводить состояния истории и наблюдать за жизнью колонии. Как же вывести на экран состояние автомата? Предлагаем следующий способ:
1. В двоичной (из 0 и 1) матрице (двумерном массиве), описывающей состояние автомата, заменяем все 0 на -, а 1 -- на +:
```
def symbolize(A: list, replace={0: '-', 1: '+'}) -> list:
    B = zeros(len(A))
    for i in range(len(A)):
        for j in range(len(A)):
            B[i][j] = replace[A[i][j]]
    return B
```
2. Каждую строчку полученного массива переводим из типа массив (list) в тип строка (str):
```
def strfy(a: list) -> str:
    res = ''
    for el in a:
        res += str(el)
    return res
```
3. В каждой строчке между соседними символами добавляем пробел:
```
def pad(s: str) -> str:
    res = ''
    for letter in s:
        res += letter + ' '
    return res
```
4. Выводим все строчки.

Функция, отвечающая за перевод и печать состояния автомата, выглядит так (заметьте, что к каждой строчке применяется последовательно несколько функций -- это называется композицией):
```
def printout(A:list):
    B = symbolize(A)
    for row in B:
        print(pad(strfy(row)))
```